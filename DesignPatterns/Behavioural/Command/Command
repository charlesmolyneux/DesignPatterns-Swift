Name: Command
Pattern Type: Behavioural
Aliases: Action, Transaction
  
Summary:
  Command turns requests into stand-alone objects that contain all the information they require for that request.
 
Example:
 Imagine having a 'Button' class that could be used on the navigation bar, toolbar and on screen. Whilst they may seem similar they might all have different handlers. This can lead to subclass hell. Where each subclass handles the button tap execution (i.e. SaveButton, CancelButton, SubmitButton, OkButton). This not only creates a large amount of subclasses but also each time you modify the parent Button class you may break your subclasses.
 
Solution:
 Seperation of Concerns is what will save the day here. Seperate the GUI and Business Logic layers. UI objects should not send requests directly, rather extract the details into a seperate command method that can then trigger the request.
 
Pros:
- SRP: Decouples classes, seperates classes which invoke operations from those that perform operations.
- OCP: Introduce new commands into the app without breaking existing code.
- Implement Undo/Redo. Stores a lis of operations.
 
 Cons:
 - Code may increase in complexity as you introduce new layers.
  
-----------

1. Receiver: Does the actual work. (Networking Request, DB Operation, Business Logic, Algorithims etc)
2. Command: Protocol with a handful of functions. Commands are handled by the invoker. (Concrete Implementation will take an instance of the receiver).
3. Invoker: Calls the execute function on the commands. It might have an array of commands and will decide when to execute them.
4. Client: Creates concrete command objects and passes them to the invoker.
